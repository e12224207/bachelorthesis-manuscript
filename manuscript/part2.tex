%=== Part II - Design \& Implementation ===%
\part{Design \& Implementation}

\chapter{Requirements and Technological Context}

As discussed in in the introduction \ref{sec:scope}, the main aim is the development of a VS Code Language extension that operates on par with
well-established tooling for other programming languages. The following requirements define the expected capabilities and characteristics the extension must demonstrate.

\begin{multicols}{2}
  \subsection*{Functional Requirements}
  \begin{enumerate}
    \item The extension must provide syntax highlighting for the target language, differentiating keywords, operators, literals, and identifiers.
    \item The extension must provide basic code completion suggestions based on language keywords and the abstract syntax tree (AST) generated by Langium.
    \item The extension must be able to validate data types within the language, providing warnings or errors when type mismatches occur.
    \item The extension must perform semantic analyses to detect invalid constructs, undefined variables, and other semantic errors.
    \item The extension must display syntax and semantic error messages in the editor in real-time as the user edits the code.
    \item The extension must utilize the Langium framework for language specification, parser generation, and language service implementation.
  \end{enumerate}

  \columnbreak

  \subsection*{Non-Functional Requirements}
  \begin{enumerate}
    \item The extension must respond to user edits with syntax and semantic feedback within 100-250ms for files of average size.
    \item The extension must provide a user-friendly experience that is consistent with other popular VS Code extensions.
    \item The extension must be structured and commented in a way that allows future developers to understand and extend its functionality easily.
    \item The extension must be compatible with the latest version of Visual Studio Code at the time of its release and be developed using Langium, with consideration for future maintenance and version support.
    \item The extension must be able to handle files of immense size (around 10000 lines) of code within the bounds of 1 second.
    \item The extension must be delivered with clear and comprehensive documentation, including installation, usage, and extension of its features.
  \end{enumerate}
\end{multicols}

\section{Alternative Technologies}

This extension is implemented using \textbf{Langium}, which itself builds upon the standardized \textbf{Language Server Protocol (LSP)}~\cite{LSP}, yet
there are several other technologies and approaches available for creating Visual Studio Code language extensions. At its core, the LSP allows tooling for programming
languages to be developed in a modular, editor-independent manner, making it possible to implement a language server in any language that can communicate via JSON-RPC.

One common approach is to implement a language server using general-purpose programming languages (e.g., TypeScript, Java, or Rust) combined with parser generation libraries.
Technologies such as \textbf{Jison}~\cite{Jison}, \textbf{Nearley}~\cite{Nearley}, and \textbf{PEG.js}~\cite{PEGjs} offer a range of options for specifying a language's grammar
and creating a parser. These libraries vary in design and capabilities and may need extra components, such as dedicated lexers and scoping to enable fully-fletched tooling.

In contrast, more comprehensive technologies such as \textbf{ANTLR}~\cite{ANTLR} and \textbf{Langium} go beyond
basic parsing. ANTLR provides a mature and highly optimized lexer and parser generation framework that is widely used across many programming languages, while Langium offers
an end-to-end solution for language engineering - including built-in support for scoping, indexing, and validation - making it especially suited for creating fully
featured language servers.

For basic syntax highlighting and lexical analysis, \textbf{TextMate}-style grammars~\cite{TextMate} can be used, offering a lightweight approach when deep semantic understanding is not required.
Meanwhile, incremental parsing frameworks such as \textbf{Tree-sitter}~\cite{Treesitter} have gained popularity for their ability to provide high-performance syntax parsing and error recovery,
making them ideal for tooling that operates on very large files.

\chapter{Langium}

Langium is a young language engineering framework inspired by the accomplishments of \verb|Xtext|, striving to evolve into a similarly comprehensive and widely-used technology stack.\cite{LangiumWeb}
Its goal is to lower the barrier to entry for language design and implementation, opening the field to new users and fostering the growth of its user base.
To achieve this, Langium embraces the extensibility of the Visual Studio Code ecosystem and its extension pipeline, providing a rich set of built-in
capabilitiesâ€”including command-line tooling, code generation, interpretation, and seamless editor integration. All of this is pursued with a strong focus on quality and
maintainability, ensuring that both newcomers and experienced developers can build robust, sustainable language tooling and domain-specific environments.

Although Langium is capable of defining general-purpose languages, its design is primarily optimized for domain-specific languages (DSLs), targeting languages with a limited range of abstraction and complexity.
Creating a fully featured GPL is a highly exhaustive endeavor that demands extensive semantic modeling, thorough tooling, and a substantial team of developers.
In contrast, Langium is tailored to lower the entry barrier for language design, making it an ideal choice for building DSLs that solve specific, well-defined problems.
\\
t

\section{Language Server Protocol}


\section{Data Flow and Control Flow}
\section{Language Server Protocol}

custom providers, computators

\chapter{Implementation Details}
\label{sec:langium-grammar}
\section{Langium Grammar Definition for \textit{Miniprob}}
\section{Type System and Semantic Checks}
\section{VS Code Extension Points}
textmate highlighting
\section{Testing \& Validation}

\chapter{Performance \& Usability}
\section{Parsing Speed}
\section{Editor Responsiveness}
\section{User Feedback}